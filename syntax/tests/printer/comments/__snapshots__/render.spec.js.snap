// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`binaryExpr.ns 1`] = `
"/* with comments */
compilation->Plugin.buildAssets // after
/* below compilation */ // trailing

compilation /* same line as compilation */->Plugin.buildAssets // trailing

/* with comments */
compilation
/* first */
->Plugin.buildAssets /* first trail */
/* second */
->Js.Json.stringify /* second trail */
/* last */
->Node.Fs.writeFileAsUtf8Sync(path) /* last trail */

if (
  // above1
  a == b &&
  // trailing1
  // above2
  c == d &&
  // trailing2
  // above3
  e == f &&
  // trailing3
  x
) {
  console.log(\\"foo bar\\")
}

let truth = a == b && c == d /* cmt */ && e == f

let truth =
  /* c0 */ a /* c1 */ == /* c2 */ b /* c3 */ &&
  /* c4 */ c /* c5 */ == /* c6 */ d /* c7 */ &&
  /* c8 */ e /* c9 */ == /* c10 */ f /* c11 */
"
`;

exports[`blockExpr.ns 1`] = `
"let () = /* c0 */ sideEffect1() /* c1 */

let () = {
  /* c0 */ sideEffect1() /* c1 */
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  /* c2 */ sideEffect2() /* c3 */
}

let () = {
  /* c0 */ sideEffect1() // c1
  // c2

  // c3
  /* c4 */ sideEffect2() // c5
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  /* c2 */ sideEffect2() /* c3 */
  /* c4 */ sideEffect3() /* c5 */
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  // k

  // k2
  /* k3 */
  // k4

  // k5
  /* c2 */ sideEffect2() /* c3 */
  // k

  // k2
  /* k3 */
  // k4

  // k5
  /* c4 */ sideEffect3() /* c5 */
}

let () = {
  /* c0 */ sideEffect1() /* c1 */
  /* c2 */ sideEffect2() /* c3 */
  /* c4 */ sideEffect3() /* c5 */
  /* c6 */ sideEffect4() /* c7 */
}

let () = {
  /* c0 */ let a /* inside */ = 1 /* c1 */
  /* c2 */ sideEffect2() /* c3 */
}

let () = {
  /* c0 */ let a /* inside */ = 1 /* c1 */
  // k

  // k2
  /* k3 */ /* k4 */

  // k5
  /* c2 */ sideEffect2() /* c3 */
}

let () = {
  /* c0 */ let a /* inside a */ = 1 /* c1 */
  /* c2 */ let b /* inside b */ = 2 /* c3 */
  /* c4 */ a + b /* c5 */
}

let () = {
  /* c0 */ let a /* inside a */ = 1 /* c1 */
  // k

  // k2
  /* k3 */ /* k4 */

  // k5
  /* c2 */ let b /* inside b */ = 2 /* c3 */
  // k

  // k2
  /* k3 */ /* k4 */

  // k5
  /* c4 */ a + b /* c5 */
}

let () = {
  /* c0 */ let a /* inside a */ = 1 /* c1 */
  /* c2 */ let b /* inside b */ = 2 /* c3 */
  /* c4 */ let c /* inside c */ = 3 /* c5 */
  /* c5 */ a + b + c /* c6 */
}

let () = {
  /* c0 */ exception /* inside */ Exit /* c1 */
  /* c2 */ raise(Exit) /* c3 */
}

let () = {
  /* c0 */ exception /* inside */ Exit // c1
  // k

  // k2
  /* c2 */ raise(Exit) // c3
}

let () = {
  /* c0 */ exception /* inside */ Exit /* c1 */
  /* c2 */ exception /* inside */ Terminate /* c3 */
  /* c4 */ raise(Exit) /* c5 */
}

let () = {
  /* c0 */ exception /* inside */ Exit // c1
  // k

  // k2

  // k3
  /* c2 */ exception /* inside */ Terminate // c3
  // k

  // k2

  // k3
  /* c4 */ raise(Exit) /* c5 */
}

let () = {
  /* c0 */ exception /* inside */ Exit /* c1 */
  /* c2 */ exception /* inside */ Terminate /* c3 */
  /* c4 */ exception /* inside */ Oom /* c5 */
  /* c6 */ raise(Exit) /* c7 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger /* c4 */
  /* c5 */ L.log() /* c6 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger // c4
  // k

  // k2

  // k3
  /* c5 */ L.log() /* c6 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger /* c4 */
  /* c5 */ module /* c6 */ L2 /* c7 */ = /* c8 */ Logger2 /* c9 */
  /* c10 */ L.log() /* c11 */
  /* c12 */ L2.log() /* c13 */
}

let () = {
  /* c0 */ module /* c1 */ L /* c2 */ = /* c3 */ Logger /* c4 */
  // k

  /* k1 */

  // k2
  /* c5 */ module /* c6 */ L2 /* c7 */ = /* c8 */ Logger2 /* c9 */
  // k

  /* k1 */

  // k2
  /* c10 */ L.log() /* c11 */
  // k

  /* k1 */

  // k2
  /* c12 */ L2.log() /* c13 */
}

let () = {
  /* c0 */ open /* c1 */ Belt /* c2 */
  /* c3 */ doSomething() /* c4 */
}

let () = {
  /* c0 */ open /* c1 */ Belt // c2
  // k

  /* k2 */

  // k3
  /* c3 */ doSomething() // c4
}

let () = {
  /* c0 */ open /* c1 */ Belt /* c2 */
  /* c3 */ open /* c4 */ React /* c5 */
  /* c6 */ doSomething() /* c7 */
}

let () = {
  /* c0 */ open /* c1 */ Belt /* c2 */
  // k

  /* k2 */

  // k3
  /* c3 */ open /* c4 */ React /* c5 */
  // k

  /* k2 */

  // k3
  /* c6 */ doSomething() /* c7 */
}

while true {
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8

  // here
}

for i in 0 to 10 {
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8

  // here
}

switch color {
| Blue =>
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8

| Red =>
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8
}

try danger() catch {
| Exc =>
  /* c0 */ let () = sideEffect1() // c1
  // c2

  /* c3 */ let () = sideEffect2() // c4
  // c5

  // c6
  /* c7 */ sideEffect2() // c8
}

if {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false // trailing

  // between
  true // test

  /* ws */
  // after
} {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false
  false // here
} else {
  // here
  let a = true
  // okok

  // there
  let b = false
  true
} // trailing

if {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false // trailing

  // between
  true // test

  /* ws */
  // after
} {
  // here
  let a = true
  // okok

  // there
  let /* inside */ b = false
  false // here
} else if {
  let u = universe() // c0
  // c1

  // c2
  let /* inside */ gc = forceGc() // stop the world
  // c3

  // c4
  f(u, gc) // c5
  /* c6 */
  // c7
} {
  // here
  let a = true
  // okok

  // there
  let b = false
  true
} // trailing

assert {
  // here
  open /* inside */ Matrix
  // c

  // c2
  compare(m1, m2)
  // after

  // test
}

lazy {
  // here
  open /* inside */ Matrix
  // c

  // c2
  compare(m1, m2)
  // after

  // test
}

user.name = {
  // here
  open /* inside */ Names

  // c

  // c2
  defaultName
  // after

  // test
}

switch {
  // here
  open Matrix
  // there

  // test
  arityCheck()
  // trailing

  // hmm
} {
| One => ()
| Two => ()
}

try {
  // here
  open Matrix
  // there

  // test
  arityCheck()
  // trailing

  // hmm
} catch {
| One => ()
| Two => ()
}

let () = {
  // here
  open Matrix

  // there

  // test
  arityCheck
  // trailing

  // hmm
}(arg1, arg2)

let name = {
  // here
  open Users

  // there

  // test
  defaultUser
  // trailing

  // hmm
}.name

let () = {
  // here
  open Users

  // there

  // test
  defaultUser
  // trailing

  // hmm
}.name = {
  // here
  open Names

  // there

  // test
  defaultName
  // trailing

  // hmm
}

while {
  // comment
  open Conditions
  // inside

  // inside2
  check()
  // foo

  // bar
} {
  Js.log(\\"test\\")
}

let multiply = (/* c0 */ m1 /* c1 */, /* c2 */ m2 /* c3 */) => {
  // here
  open Matrix4D

  let m3 = makeUninitializedUnsafe()

  // there

  // over there
  m3
  /* trailing */
  // test
}

switch x {
| Blue when /* c0 */ multicore.enabled /* c1 */ === /* c2 */ true /* c3 */ => ()
| Red
  when {
    // c0
    open /* c1 */ Multicore // c2
    // c3

    // c4
    isEnabled() // c5
    /* c6 */

    // c7
  } => ()
}
"
`;

exports[`case.ns 1`] = `
"let rec mergeU = (s1, s2, f) =>
  switch {
    open N
    (toOpt(s1), toOpt(s2))
  } {
  | (None, None) => N.empty
  | (Some(n) /* (Node (l1, v1, d1, r1, h1), _) */, _)
    when {
      open N
      heightGet(n) >=
      switch N.toOpt(s2) {
      | None => 0
      | Some(n) => N.heightGet(n)
      }
    } =>
    let (l1, v1, d1, r1) = {
      open N
      (leftGet(n), keyGet(n), valueGet(n), rightGet(n))
    }
    let (l2, d2, r2) = split(v1, s2)
    N.concatOrJoin(
      mergeU(l1, l2, f),
      v1,
      f(. v1, Some(d1), d2),
      mergeU(r1, r2, f),
    )
  | (_, Some(n)) /* Node (l2, v2, d2, r2, h2) */ =>
    let (l2, v2, d2, r2) = {
      open N
      (leftGet(n), keyGet(n), valueGet(n), rightGet(n))
    }
    let (l1, d1, r1) = split(v2, s1)
    N.concatOrJoin(
      mergeU(l1, l2, f),
      v2,
      f(. v2, d1, Some(d2)),
      mergeU(r1, r2, f),
    )
  | _ => assert false
  }
"
`;

exports[`expr.ns 1`] = `""`;

exports[`extensionConstructor.ns 1`] = `
"/* c0 */ exception /* c1 */ Exit /* c2 */ = /* c3 */ Terminate /* c4 */

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
) // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
): /* c8 */ gadt // after

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */</* c1.1 */ 'x /* c2.2 */> +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ += /* c3 */ Bar /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ +=
  | /* c3 */ Foo /* c4 */ = /* c5 */ Bar /* c6 */
"
`;

exports[`fileWithOneSingleLineComment.ns 1`] = `
"// retain this comment
"
`;

exports[`fileWithOnlyComments.ns 1`] = `
"// test

/* multi
line
comment
*/

// more comments
"
`;

exports[`ifLet.res 1`] = `
"if let /* c0 */ /* c1 */ Some(
  /* c2 */ x /* c3 */,
) /* c4 */ = /* c5 */ makeOpt() /* c6 */ {
  /* c7 */ foo() /* c8 */
} else {
  /* c9 */ bar() /* c10 */
}

let getZ2 = nested =>
  if let /* c-4 */ Some(point) /* c-3 */ = /* c-2 */ nested.origin /* c-1 */ {
    if let /* c0 */ Some(/* c1 */ z /* c2 */) = /* c3 */ point.z /* c4 */ {
      let pi /* inside */ = 3.13 *. point.z // trailing1
      let e /* inside1 */ = 42.3 // trailing2
      pi *. e // trailing3
    } else {
      let pi /* inside2 */ = 3.13 // trailing4
      let e /* inside3 */ = 42.3 // trailing5
      pi *. e // trailing6
    }
  } else {
    let pi /* inside4 */ = 3.13 // trailing7
    let e /* inside5 */ = 42.3 // trailing8
    pi *. e // trailing9
  }
"
`;

exports[`interfaceWithOneSingleComment.nsi 1`] = `
"// retain this comment
"
`;

exports[`interfaceWithOnlyComments.nsi 1`] = `
"// test

/* test */

// ok
"
`;

exports[`jsx.ns 1`] = `
"module Cite = {
  @react.component
  let make = (~author: option<string>, ~children) => {
    // For semantics, check out
    // https://css-tricks.com/quoting-in-html-quotations-citations-and-blockquotes/
    <div> foo </div>
  }
}
"
`;

exports[`modExpr.ns 1`] = `
"// Pmod_ident
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ Y /* c4 */

// Pmod_structure
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ {
  let /* inside1 */ a /* inside2 */ = 2 /* trailing */
} // trailing

// Pmod_extension
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ %ext(
  /* c4 */ \\"test\\" /* c5 */
) /* c6 */

// Pmod_unpack
/* c0 */ module /* c1 */ New_three /* c2 */ = /* c3 */ unpack(
  /* c4 */ three /* c5 */: /* c6 */ X_int /* c7 */
) /* c8 */

// Pmod_constraint
/* c0 */ module /* c1 */ X /* c2 */: /* c5 */ Int /* c6 */ = /* c3 */ X /* c4 */
/* c0 */ module /* c1 */ X /* c2 */: /* c4 */ Int /* c5 */ = /* c6 */ X /* c7 */

// Pmod_apply
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ F /* c4 */(
  /* c4 */ Arg1 /* c5 */,
  /* c6 */ Arg2 /* c7 */,
  /* c8 */ Arg3 /* c9 */,
) /* c10 */
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ F(
  /* c4 */ A /* c5 */: /* c6 */ SetLike /* c7 */,
  /* c7 */ B /* c8 */: /* c9 */ TreeLike /* c10 */,
) /* c11 */
/* c0 */ module /* c1 */ S0 /* c2 */ = /* c3 */ Make /* c4 */(/* lbrace */ {
  type t = int /* c5 */
  let eq /* c6 */ = (x, y) => x == y
} /* rbrace */) // trailing

// Pmod_functor
/* c0 */ module /* c1 */ F /* c2 */ = /* before parameters */ (
  /* c3 */ A /* c4 */: /* c5 */ X /* c6 */,
  /* c7 */ B /* c8 */: /* c9 */ Y /* c 10 */,
  /* c7 */ C /* c8 */: /* c9 */ Z /* c 10 */,
) => /* c11 */ ReturnMod /* c12 */

module Make = /* before parameters */ (
  /* before A */ A /* after A */: /* before X */ X /* after X */,
  /* before B */ B /* after B */: /* before Y */ Y /* after Y */,
): /* c1 */ Set /* c2 */ => {
  let a /* inside */ = A.a + B.b
}

module Make = /* before parameters */ (
  /* before A */ A /* after A */: /* before X */ X /* after X */,
  /* before B */ B /* after B */: /* before Y */ Y /* after Y */,
): /* c1 */ Set /* c2 */ => {
  let a /* inside */ = A.a + B.b
}
"
`;

exports[`modType.ns 1`] = `
"// Pmty_ident
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ Tree /* c4 */

// Pmty_signature
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ {
  let a: int
} /* c4 */

// Pmty_extension
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ %ext(
  /* c4 */ \\"test\\" /* c5 */
) /* c6 */

// Pmty_typeof
/* c0 */ module type /* c1 */ A /* c2 */ = /* c3 */ module type of /* c4 */ {
  let a /* inside */ = 1
} /* c5 */

// Pmty_with
/* c0 */ module type /* c1 */ A /* c2 */ = /* c3 */ Foo /* c4 */
  with type t = string // end

// Pmty_functor
/* c0 */ module type /* c1 */ Functor /* c2 */ = /* c3 */ SetLike /* c4 */ =>
/* c5 */ Set /* c6 */
module type Functor = /* before */ (
  /* before S */ S /* after S */: /* before */ SetLike /* after */,
  /* before B */ B /* after B */: /* before */ BtreeLike /* after */,
) => /* before NeoTree */ NeoTree // after NeoTree
module type Functor = (
  /* c0 */ /* c1 */ /* c2 */ SetLike /* c3 */,
  /* c4 */ /* c5 */ /* c6 */ BtreeLike /* c7 */,
) => NeoTree

module type Functor = /* before */ (
  /* c0 */ SetLike /* c1 */,
  /* c2 */ BtreeLike /* c3 */,
) => NeoTree
"
`;

exports[`multiline.ns 1`] = `
"/* first line
 * the leading stars
 * should align here.
 */
let f = () => ()

/* first line
 * second line
 * third line */

/* first line
 *
 * third line */

/* x */
/*  */
/*  */
/*  */

/**
 * test
 */

/* BuckleScript outperforms a classic for-loop: 
   function equals3(m1, m2) {
    for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
            var x = m1[i][j];
            var y = m2[i][j];
            if(!floatEquals(x, y)) {
                return false
            }
        }
    }
    return true
  } */
let equals = (matrix1, matrix2) => {
  let rec loop = (i, j) =>
    if i > 3 {
      true
    } else {
      let x = matrix1->getUnsafe(~row=i, ~col=j)
      let y = matrix2->getUnsafe(~row=i, ~col=j)
      if !Float.equals(x, y) {
        false
      } else if j < 3 {
        loop(i, j + 1)
      } else {
        loop(i + 1, 0)
      }
    }

  loop(0, 0)
}

/*
foo
bar
*/

/*



foo
bar
*/

/*



foo




bar



*/

/* multi
line
comment
*/

/*
multi
line
comment */
"
`;

exports[`namedArgs.ns 1`] = `
"let wizard = Wizard.make(
  ~spriteSheet=wizard,
  ~hp=999999999999999,
  ~mp=50,
  // ~coordinates={x: 0., y:0. z: 0.},
  ~coordinates={x: 40, y: 100., z: 0.},
  /* c0 */ ~gpuCoordinates=/* c1 */ gpuBuffer[10] /* c2 */, // trailing
)

apply(
  // above
  ~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  // below
  ~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,
  // here
  ~cccccccccccccccccccccccccccccccc,
)

applyOptional(
  // above
  ~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa?,
  // below
  ~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb?,
  // here
  ~cccccccccccccccccccccccccccccccc?,
)

foo(
  // c0
  ~aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: int,
  // c1
  ~bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: int,
  // c2
  ~cccccccccccccccccccccccccccccc: int,
)

let f = (
  ~isItemActive=?,
  // array((name, href))
  ~headers: array<(string, string)>,
  ~moduleName: string,
  // foo
  ~x,
  // above
  /* c0 */ ~d: /* c1 */ e, // end
  // does it work
  ~from as hometown,
) => {
  let a = 1
  let b = 2
  a + b
}

@react.component
let make = (
  ~theme: ColorTheme.t,
  ~components: Mdx.Components.t,
  ~sidebarState: (bool, (bool => bool) => unit),
  // (Sidebar, toggleSidebar) ... for toggling sidebar in mobile view
  ~sidebar: React.element,
  ~breadcrumbs: option<list<UrlPath.breadcrumb>>=?,
  ~children,
) => {
  ()
}
"
`;

exports[`openDescription.ns 1`] = `
"open /* leading */ React /* trailing */
open /* leading */ React /* trailing */
open /* leading */ React // trailing
"
`;

exports[`pattern.ns 1`] = `""`;

exports[`signatureItem.nsi 1`] = `
"// Psig_value
/* c0 */ external /* c1 */ force_gc /* c2 */: /* c3 */ unit /* c4 */ => /* c5 */ unit /* c6 */ =
  \\"gc\\" // trailing

// Psig_type
/* c0 */ type /* c1 */ t /* c2 */ = /* c3 */ string /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ = /* c4 */ string /* c5 */
// above
and /* c6 */ s /* c7 */ = /* c8 */ int /* c9 */

// Pstr_typext
/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */</* c1.1 */ 'x /* c2.2 */> +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ += /* c3 */ Bar /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ +=
  | /* c3 */ Foo /* c4 */ = /* c5 */ Bar /* c6 */

// Pstr_exception
/* c0 */ exception /* c1 */ Exit /* c2 */ = /* c3 */ Terminate /* c4 */

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
) // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
): /* c8 */ gadt // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */({
  /* c4 */ code /* inside */: /* inside2 */ int /* c5 */,
  /* c6 */ timeout /* inside */: /* inside2 */ int /* c7 */,
}): /* c8 */ gadt // after

// Psig_module
/* c0 */ module /* c1 */ X /* c2 */: /* c3 */ MT /* c4 */

// Psig_module
/* c0 */ module rec /* c1 */ X1 /* c2 */: /* c3 */ MT1
// above
and /* c4 */ Xn /* c5 */: /* c6 */ MTn /* c7 */

// Psig_modtype
/* c0 */ module type /* c1 */ S /* c2 */ = /* c3 */ MT /* c4 */
/* c0 */ module type /* c1 */ S /* c2 */

// Psig_open
/* c0 */ open /* c1 */ Belt /* c2 */

// Psig_include
/* c0 */ include /* c1 */ {
  let a /* inside */: int
} // after

// Psig_attribute
/* c0 */ @@attr(/* c1 */ payload /* c2 */) /* c3 */

// Psig_extension
/* c0 */ @@extension(/* c1 */ payload /* c2 */) /* c3 */
"
`;

exports[`structure1.ns 1`] = `
"// leading single line 1a
// leading single line 1b
/* leading multiline 1c */
/* leading multiline 1d */
/* leading multiline attached to node */ let a = 1 // trailing1

// leading2
/* before */ let b = 2 /* trailing2 */
/* under b */

/* here */

// lala

/* test */ /* okok */

// above open
open /* here */ React // after
// trailing
/* foo */
/* bar */

// another
// ok

// end
"
`;

exports[`structure2.ns 1`] = `
"let b = 2
/* test */ // sldkfj

// sldkfj

/* help */ /* help2 */

/* test2 */
open /* before lident */ React
"
`;

exports[`structure3.ns 1`] = `
"node.left->peekMinNode
// same as the above
node.left->peekMinNode

// field access has higher precedence than unary -
let x = -a.bar

let a = 1

/* test */
let b = 2
// a
// b
"
`;

exports[`structure4.ns 1`] = `
"let user = {
  name: \\"steve\\",
  age: 31,
}

/* A comment */
/**
 * A type that can be written to a buffer.
 */
/**
 * Describes the connection status of a ReactiveSocket/DuplexConnection.
 * - NOT_CONNECTED: no connection established or pending.
 * - CONNECTING: when \`connect()\` has been called but a connection is not yet
 *   established.
 * - CONNECTED: when a connection is established.
 * - CLOSED: when the connection has been explicitly closed via \`close()\`.
 * - ERROR: when the connection has been closed for any other reason.
 */
/**
 * A contract providing different interaction models per the [ReactiveSocket protocol]
 * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
 */
/**
 * A single unit of data exchanged between the peers of a \`ReactiveSocket\`.
 */
"
`;

exports[`structureItem.ns 1`] = `
"// Pstr_attribute
@@attr(/* c0 */ \\"here\\" /* c1 */)

// Pstr_extension
%%extension(/* c0 */ \\"here\\" /* c1 */)

// Pstr_include
/* c0 */ include /* c1 */ Belt /* c2 */
/* c0 */ include /* c1 */ {
  let a /* inside */ = 2
} /* c2 */

// Pstr_open
/* c0 */ open /* c1 */ Belt /* c2 */

// Pstr_modtype
/* c0 */ module type /* c1 */ T /* c2 */ = /* c3 */ MT /* c4 */

// Pstr_recmodule
/* c0 */ module rec /* c1 */ X1 /* c2 */ = /* c3 */ ME1 /* c4 */
// above
and /* c5 */ Xn /* c6 */ = /* c7 */ MEn /* c8 */

// Pstr_module
/* c0 */ module /* c1 */ X /* c2 */ = /* c3 */ Y /* c4 */

// Pstr_exception
/* c0 */ exception /* c1 */ Exit /* c2 */ = /* c3 */ Terminate /* c4 */

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
) // after

/* c0 */ exception /* c1 */ ExitEarly /* c2 */(
  /* c4 */ int /* c5 */,
  /* c6 */ int /* c7 */,
): /* c8 */ gadt // after

// Pstr_typext
/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */</* c1.1 */ 'x /* c2.2 */> +=
  | /* before Foo */ Foo // after Foo
  | /* before Bar */ Bar // after Bar

/* c0 */ type /* c1 */ Foo.Bar.t /* c2 */ += /* c3 */ Bar /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ +=
  | /* c3 */ Foo /* c4 */ = /* c5 */ Bar /* c6 */

// Pstr_type
/* c0 */ type /* c1 */ t /* c2 */ = /* c3 */ string /* c4 */

/* c0 */ type /* c1 */ t /* c2 */ = /* c4 */ string /* c5 */
// above
and /* c6 */ s /* c7 */ = /* c8 */ int /* c9 */

// Pstr_primitive
/* c0 */ external /* c1 */ force_gc /* c2 */: /* c3 */ unit /* c4 */ => /* c5 */ unit /* c6 */ =
  \\"gc\\" // trailing

// Pstr_eval
/* c0 */ user.name /* c1 */ = /* c2 */ \\"Steve\\" /* c3 */
"
`;

exports[`trailingComments.ns 1`] = `
"let user = {
  name: \\"steve\\",
  age: 31 /* here */, // test

  /* test */
  /* test2 */

  // test3

  /* test 4 */
}

/* A */
/**
 * A type that can be written to a buffer.
 */
/**
 * Describes the connection status of a ReactiveSocket/DuplexConnection.
 * - NOT_CONNECTED: no connection established or pending.
 * - CONNECTING: when \`connect()\` has been called but a connection is not yet
 *   established.
 * - CONNECTED: when a connection is established.
 * - CLOSED: when the connection has been explicitly closed via \`close()\`.
 * - ERROR: when the connection has been closed for any other reason.
 */
/**
 * A contract providing different interaction models per the [ReactiveSocket protocol]
 * (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
 */
/**
 * A single unit of data exchanged between the peers of a \`ReactiveSocket\`.
 */
"
`;

exports[`typeDefinition.js 1`] = `
"/* before */ type t /* after */
/* before */ type /* before name */ t /* after name */ /* after */

/* before */ type t = .. /* after */
/* before */ type /* before name */ t /* after name */ = .. /* after */

/* before */ type t<
  /* c0 */ 'err /* c1 */,
  /* c2 */ 'success /* c3 */,
> /* after */
/* before */ type /* before name */ t /* after name */<
  /* c0 */ 'err /* c1 */,
  /* c2 */ 'success /* c3 */,
> /* after */

/* before */ type t = /* before manifest */ string /* after */
/* before */ type /* before name */ t /* after name */ = /* before manifest */ string /* after */
/* before */ type /* before name */ t /* after name */<
  /* c0 */ 'err /* c1 */,
  /* c2 */ 'success /* c3 */,
> = /* before manifest */ string /* after */

/* before */ type /* before name */ t /* after name */ =
  // above Red
  | Red // trailing Red
  // above Blue
  | Blue // trailing Blue
  // above Green
  | Green // trailing Green

/* before */ type /* before name */ t /* after name */ = /* before manifest */ Colour.t /* after manifest */ =
  // above Red
  | /* before Red */ Red // trailing Red
  // above Blue
  | /* before Blue */ Blue // trailing Blue
  // above Green
  | /* before Green */ Green /* trailing Green */ // test

type color =
  | /* before Red */ Red /* after Red */: /* before gadt */ color /* after gadt */
  | /* before Blue */ Blue /* after Blue */: /* before gadt */ color /* after gadt */

type color =
  /* before constr */ | Rgb(
      /* after constructor */ /* before red */ red,
      green,
      blue,
    )

type color =
  | /* before constr */ Rgb /* after constructor */(
      /* before red */ red /* after red */,
      /* before green */ green /* after green */,
      /* before blue */ blue /* after blue */,
    )

type color =
  | /* before constr */ Rgb /* after constructor */({
      /* before red */ red /* after red */: /* before typ */ someNumber /* after typ */,
      /* before green */ green /* after green */: /* before typ */ someNumber /* after typ */,
      /* before blue */ blue /* after blue */: /* before typ */ someNumber /* after typ */,
    })

type color = {
  /* before red */ red /* after red */: /* before typ */ someNumber /* after typ */,
  /* before green */ green /* after green */: /* before typ */ someNumber /* after typ */,
  /* before blue */ blue /* after blue */: /* before typ */ someNumber /* after typ */,
}

type /* c0 */ color /* c1 */ = /* before manifest */ Colour.t /* after manifest */ = {
  /* before red */ red /* after red */: /* before typ */ someNumber /* after typ */,
  /* before green */ green /* after green */: /* before typ */ someNumber /* after typ */,
  /* before blue */ blue /* after blue */: /* before typ */ someNumber /* after typ */,
}

type domProps = {
  @bs.optional
  viewTarget: string,
  @bs.optional
  visibility: string,
  /* width::string? => */
  @bs.optional
  widths: string,
  @bs.optional
  wordSpacing: string,
  @bs.optional
  writingMode: string,
  @bs.optional
  x: string,
  @bs.optional
  x1: string,
}

@bs.deriving(abstract)
type t = {
  /* MDX shortnames for more advanced components */
  @bs.as(\\"Cite\\")
  cite: React.component<{
    \\"author\\": option<string>,
    \\"children\\": React.element,
  }>,
  @bs.as(\\"Info\\") @bs.optional
  info: React.component<props>,
}

type rec t = {
  facing: facing,
  // frames
}
"
`;

exports[`typexpr.ns 1`] = `
"// Ptyp_any
type t = /* before */ _ /* after */

// Ptyp_var
type t = /* before */ 'a /* after */

// Ptyp_tuple
// sigh… conflicts

// Ptyp_constr
type t = /* before */ string /* after */
type t = /* before */ option /* c0 */</* c1 */ string /* c2 */> /* after */
type t = /* before */ result /* c0 */<
  /* c1 */ success /* c2 */,
  /* c3 */ err /* c4 */,
> /* after */

// Ptyp_extension
type t = /* before */ %ext(/* before */ \\"here\\" /* after */) /* after */

// Ptyp_package
type t = /* c0 */ module(/* before */ S /* after */) /* c1 */

type t = /* c0 */ module(/* c1 */ Hashmap /* c2 */ with
  /* c3 */ type key /* c4 */ = /* c5 */ string /* c6 */
)

// Ptyp_alias
type t = /* c0 */ string /* c1 */ as 'x // after

// Ptyp_poly
type fn = {f: /* c0 */ 'a /* c1 */ 'b /* c2 */. /* c3 */ string /* c4 */}

// Ptyp_arrow
type add = /* before */ (
  /* c0 */ int /* c1 */,
  /* c2 */ int /* c3 */,
) => /* before return */ int /* after */
type add = /* before */ (
  ~a: /* c0 */ int /* c1 */,
  ~b: /* c2 */ int /* c3 */,
) => /* before return */ int /* after */
type multiply = /* before */ (
  ~fn: /* c0 */ (
    /* cinner0 */ int /* cinner1 */,
    /* cinner2 */ int /* cinner3 */,
  ) => /* cx */ int /* c1 */,
  ~b: /* c2 */ int /* c3 */,
) => int /* after */

// Ptyp_object
type jsUser = /* before */ {
  // above name
  /* before name */ \\"name\\" /* after name */: /* before typ */ string /* after typ */,
  // above age
  /* before age */ \\"age\\" /* after age */: /* before int */ int /* after int */,
} /* after */
"
`;

exports[`valueBindings.ns 1`] = `""`;

exports[`whitespaceCase1.ns 1`] = `
"let x = 1
// comment

let 123 = 123
// comment2
let f = ()
"
`;

exports[`whitespaceCase2.ns 1`] = `
"let a = 2 // c2

let b = 1
"
`;

exports[`whitespaceLeadingComment.ns 1`] = `
"// the comment \\"assert Tuple\\" should contain whitespace before/after
let () = {
  let point = Tuple.makePoint(0., 1., 0.)
  let halfQuarter = rotationX(Js.Math._PI /. 4.)
  let fullQuarter = rotationX(Js.Math._PI /. 2.)

  /* assert Tuple.equals(
    halfQuarter->applyTo(point),
    Tuple.makePoint(0., Js.Math.sqrt(2.) /. 2., Js.Math.sqrt(2.) /. 2.),
  ) */

  assert Tuple.equals(fullQuarter->applyTo(point), Tuple.makePoint(0., 0., 1.))
}
"
`;

exports[`whitespaceTrailingLeading.ns 1`] = `
"let a = 1 // single line trailing
// leading
let b = 2

let a = 1 /* comment */
// leading
let b = 2

let a = 1 // single line trailing

// leading
let b = 2

let a = 1 /* comment */

// leading
let b = 2
"
`;
